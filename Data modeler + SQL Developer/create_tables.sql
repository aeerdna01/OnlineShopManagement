-- Generated by Oracle SQL Developer Data Modeler 22.2.0.165.1149
--   at:        2023-01-18 01:46:57 EET
--   site:      Oracle Database 12c
--   type:      Oracle Database 12c



-- predefined type, no DDL - MDSYS.SDO_GEOMETRY

-- predefined type, no DDL - XMLTYPE

CREATE TABLE sizes (
    id_size NUMBER(1) NOT NULL,
    name    VARCHAR2(3) NOT NULL
)
LOGGING;

ALTER TABLE sizes
    ADD CONSTRAINT sizes_name_ck CHECK ( name IN ( 'L', 'M', 'S', 'XL', 'XS',
                                                   'XXL', 'XXS' ) );

ALTER TABLE sizes ADD CONSTRAINT size_pk PRIMARY KEY ( id_size );

ALTER TABLE sizes ADD CONSTRAINT size_name_uk UNIQUE ( name );

CREATE OR REPLACE FUNCTION get_id_size (
    param_size VARCHAR2
) RETURN NUMBER IS
    var_result NUMBER;
BEGIN
    SELECT
        id_size
    INTO var_result
    FROM
        sizes
    WHERE
        name = param_size;

    IF var_result = NULL THEN
        raise_application_error(-20001, 'The given size is invalid!');
    END IF;
    RETURN var_result;
END;
/

CREATE TABLE accounts (
    id_user      NUMBER(2) NOT NULL,
    username     VARCHAR2(30) NOT NULL,
    password     VARCHAR2(31) NOT NULL,
    role         VARCHAR2(20) NOT NULL,
    total_orders NUMBER(3) DEFAULT 0
)
LOGGING;

ALTER TABLE accounts
    ADD CONSTRAINT accounts_username_ck CHECK ( length(username) >= 3
                                                AND REGEXP_LIKE ( username,
                                                                  '^[a-zA-Z_0-9]*$' ) );

ALTER TABLE accounts
    ADD CONSTRAINT accounts_password_ck CHECK ( REGEXP_LIKE ( password,
                                                              '[A-Za-z0-9][!@#$%*_]' )
                                                AND length(password) >= 8 );

ALTER TABLE accounts
    ADD CONSTRAINT accounts_role_ck CHECK ( role IN ( 'administrator', 'customer' ) );

ALTER TABLE accounts ADD CONSTRAINT accounts_total_orders_ck CHECK ( total_orders >= 0 );

ALTER TABLE accounts ADD CONSTRAINT account_pk PRIMARY KEY ( id_user );

CREATE OR REPLACE FUNCTION get_id_username (
    param_username VARCHAR2
) RETURN NUMBER IS
    var_result NUMBER;
BEGIN
    SELECT
        id_user
    INTO var_result
    FROM
        accounts
    WHERE
        username = param_username;

    IF var_result = NULL THEN
        raise_application_error(-20001, 'The customer is not registered in the database!');
    END IF;
    RETURN var_result;
END;
/

CREATE TABLE categories (
    id_category NUMBER(1) NOT NULL,
    name        VARCHAR2(30) NOT NULL
)
LOGGING;

ALTER TABLE categories
    ADD CONSTRAINT categories_name_ck CHECK ( length(name) >= 3
                                              AND REGEXP_LIKE ( name,
                                                                '^[a-zA-Z_ ]*$' ) );

ALTER TABLE categories ADD CONSTRAINT categories_pk PRIMARY KEY ( id_category );

ALTER TABLE categories ADD CONSTRAINT categories_name_uk UNIQUE ( name );

CREATE TABLE orders (
    id_order   NUMBER(2) NOT NULL,
    order_date DATE NOT NULL,
    id_user    NUMBER(2) NOT NULL,
    payment    NUMBER(4) DEFAULT 0 NOT NULL
)
LOGGING;

ALTER TABLE orders ADD CONSTRAINT order_payment_ck CHECK ( payment >= 0 );

ALTER TABLE orders ADD CONSTRAINT order_pk PRIMARY KEY ( id_order );

CREATE TABLE orders_details (
    orders_id_order     NUMBER(2) NOT NULL,
    products_id_product NUMBER(2) NOT NULL,
    order_quantity      NUMBER(3) NOT NULL
)
LOGGING;

ALTER TABLE orders_details
    ADD CONSTRAINT ord_details_quantity_ck CHECK ( order_quantity BETWEEN 1 AND 999 );

ALTER TABLE orders_details ADD CONSTRAINT orders_details_pk PRIMARY KEY ( orders_id_order,
                                                                          products_id_product );

CREATE TABLE products (
    id_product     NUMBER(2) NOT NULL,
    stock_quantity NUMBER(3) DEFAULT 0 NOT NULL,
    price          NUMBER(3) NOT NULL,
    id_category    NUMBER(1) NOT NULL,
    id_size        NUMBER(1) NOT NULL,
    type           VARCHAR2(10) NOT NULL
)
LOGGING;

ALTER TABLE products
    ADD CONSTRAINT products_stock_quantity CHECK ( stock_quantity BETWEEN 0 AND 999 );

ALTER TABLE products
    ADD CONSTRAINT products_price_ck CHECK ( price BETWEEN 10 AND 999 );

ALTER TABLE products
    ADD CONSTRAINT products_type_ck CHECK ( type IN ( 'Men', 'Women' ) );

ALTER TABLE products ADD CONSTRAINT product_pk PRIMARY KEY ( id_product );

CREATE TABLE supplies (
    supply_quantity NUMBER(3) NOT NULL,
    supply_date     DATE NOT NULL,
    id_product      NUMBER(2) NOT NULL,
    id_supply       NUMBER(2) NOT NULL
)
LOGGING;

ALTER TABLE supplies
    ADD CONSTRAINT supplies_quantity_ck CHECK ( supply_quantity BETWEEN 0 AND 999 );

ALTER TABLE supplies ADD CONSTRAINT supplies_pk PRIMARY KEY ( id_supply );

CREATE TABLE user_details (
    id_user    NUMBER(2) NOT NULL,
    first_name VARCHAR2(30) NOT NULL,
    last_name  VARCHAR2(30) NOT NULL,
    address    VARCHAR2(60) NOT NULL,
    email      VARCHAR2(60) NOT NULL,
    phone      VARCHAR2(10) NOT NULL
)
LOGGING;

ALTER TABLE user_details
    ADD CONSTRAINT user_details_first_name_ck CHECK ( length(first_name) >= 3
                                                      AND REGEXP_LIKE ( first_name,
                                                                        '^[a-zA-Z_ ]*$' ) );

ALTER TABLE user_details
    ADD CONSTRAINT user_details_last_name_ck CHECK ( length(last_name) >= 3
                                                     AND REGEXP_LIKE ( last_name,
                                                                       '^[a-zA-Z_ ]*$' ) );

ALTER TABLE user_details
    ADD CONSTRAINT user_details_address_ck CHECK ( length(address) >= 3
                                                   AND REGEXP_LIKE ( address,
                                                                     '^[a-zA-Z_ 0-9.]*$' ) );

ALTER TABLE user_details
    ADD CONSTRAINT user_details_email_ck CHECK ( REGEXP_LIKE ( email,
                                                               '[a-z0-9._%-]+@[a-z0-9._%-]+\.[a-z]{2,4}' ) );

ALTER TABLE user_details
    ADD CONSTRAINT user_details_phone_ck CHECK ( REGEXP_LIKE ( phone,
                                                               '^[0-9]{10}$' ) );

ALTER TABLE user_details ADD CONSTRAINT customer_pk PRIMARY KEY ( id_user );

ALTER TABLE user_details ADD CONSTRAINT details_email_uk UNIQUE ( email );

ALTER TABLE orders
    ADD CONSTRAINT accounts_orders_fk FOREIGN KEY ( id_user )
        REFERENCES accounts ( id_user )
    NOT DEFERRABLE;

ALTER TABLE user_details
    ADD CONSTRAINT accounts_user_details_fk FOREIGN KEY ( id_user )
        REFERENCES accounts ( id_user )
    NOT DEFERRABLE;

ALTER TABLE products
    ADD CONSTRAINT categories_products_fk FOREIGN KEY ( id_category )
        REFERENCES categories ( id_category )
    NOT DEFERRABLE;

ALTER TABLE orders_details
    ADD CONSTRAINT orders_details_orders_fk FOREIGN KEY ( orders_id_order )
        REFERENCES orders ( id_order )
    NOT DEFERRABLE;

ALTER TABLE orders_details
    ADD CONSTRAINT orders_details_products_fk FOREIGN KEY ( products_id_product )
        REFERENCES products ( id_product )
    NOT DEFERRABLE;

ALTER TABLE supplies
    ADD CONSTRAINT products_supplies_fk FOREIGN KEY ( id_product )
        REFERENCES products ( id_product )
    NOT DEFERRABLE;

ALTER TABLE products
    ADD CONSTRAINT sizes_products_fk FOREIGN KEY ( id_size )
        REFERENCES sizes ( id_size )
    NOT DEFERRABLE;

CREATE OR REPLACE TRIGGER orders_date_trg 
    BEFORE INSERT OR UPDATE ON ORDERS 
    FOR EACH ROW 
BEGIN
	 IF( TRUNC( :new.order_date ) < TRUNC( SYSDATE ) )
	THEN
	RAISE_APPLICATION_ERROR( -20001,
	'Invalid date: ' || TO_CHAR( :new.order_date, 'DD.MM.YYYY' ) || ' it should be grater than the current date!' );
	END IF;
END; 
/

CREATE OR REPLACE TRIGGER orders_payment_stock_trg 
    BEFORE INSERT OR UPDATE ON ORDERS_DETAILS 
    FOR EACH ROW 
DECLARE
    voucher number;
BEGIN
    update products
    set stock_quantity = stock_quantity - :new.order_quantity
    where id_product = :new.products_id_product;

    select accounts.total_orders 
    into voucher 
    from accounts 
    where  accounts.id_user = (select id_user from orders where id_order = :new.orders_id_order);

    update orders 
    set orders.payment = orders.payment + :new.order_quantity * 
    				(select products.price from products where :new.products_id_product = products.id_product)
    where orders.id_order = :new.orders_id_order;

    IF voucher = 3 THEN
    update orders 
    set orders.payment = orders.payment - 30
    where orders.id_order = :new.orders_id_order; 
    END IF;
END; 
/

CREATE OR REPLACE TRIGGER orders_quantity_trg 
    BEFORE INSERT OR UPDATE ON ORDERS_DETAILS 
    FOR EACH ROW 
DECLARE
    available_quantity number;
BEGIN
    select products.stock_quantity 
    into available_quantity 
    from products 
    where products.id_product = :new.products_id_product;
    
    IF :new.order_quantity > available_quantity THEN
        RAISE_APPLICATION_ERROR( -20000, 'Insufficient stock! The order can not be placed!' );
    END IF;
END; 
/

CREATE OR REPLACE TRIGGER supplies_date_trg 
    BEFORE INSERT OR UPDATE ON SUPPLIES 
    FOR EACH ROW 
BEGIN
	IF( TRUNC(:new.supply_date) < TRUNC( SYSDATE ) )
	THEN
	RAISE_APPLICATION_ERROR( -20001,
	'Invalid date: ' || TO_CHAR( :new.supply_date, 'DD.MM.YYYY' ) || ' it should be grater than the current date!' );
	END IF;
END ;
/

CREATE OR REPLACE TRIGGER " supplies_stock_trg" 
    BEFORE INSERT OR UPDATE ON SUPPLIES 
    FOR EACH ROW 
BEGIN
    update products 
    set products.stock_quantity = products.stock_quantity + :new.supply_quantity
    where products.id_product = :new.id_product;
END; 
/

CREATE OR REPLACE TRIGGER total_orders_trg 
    BEFORE INSERT ON ORDERS 
    FOR EACH ROW 
BEGIN
    update accounts 
    set accounts.total_orders = accounts.total_orders + 1
    where accounts.id_user = :new.id_user; 
END; 
/

CREATE SEQUENCE accounts_id_user_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER accounts_id_user_trg BEFORE
    INSERT ON accounts
    FOR EACH ROW
    WHEN ( new.id_user IS NULL )
BEGIN
    :new.id_user := accounts_id_user_seq.nextval;
END;
/

CREATE SEQUENCE orders_id_order_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER orders_id_order_trg BEFORE
    INSERT ON orders
    FOR EACH ROW
    WHEN ( new.id_order IS NULL )
BEGIN
    :new.id_order := orders_id_order_seq.nextval;
END;
/

CREATE SEQUENCE products_id_product_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER products_id_product_trg BEFORE
    INSERT ON products
    FOR EACH ROW
    WHEN ( new.id_product IS NULL )
BEGIN
    :new.id_product := products_id_product_seq.nextval;
END;
/

CREATE SEQUENCE supplies_id_supply_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER supplies_id_supply_trg BEFORE
    INSERT ON supplies
    FOR EACH ROW
    WHEN ( new.id_supply IS NULL )
BEGIN
    :new.id_supply := supplies_id_supply_seq.nextval;
END;
/



-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                             8
-- CREATE INDEX                             0
-- ALTER TABLE                             35
-- CREATE VIEW                              0
-- ALTER VIEW                               0
-- CREATE PACKAGE                           0
-- CREATE PACKAGE BODY                      0
-- CREATE PROCEDURE                         0
-- CREATE FUNCTION                          2
-- CREATE TRIGGER                          10
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         0
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                          4
-- CREATE MATERIALIZED VIEW                 0
-- CREATE MATERIALIZED VIEW LOG             0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        0
-- CREATE USER                              0
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- TSDP POLICY                              0
-- 
-- ORDS DROP SCHEMA                         0
-- ORDS ENABLE SCHEMA                       0
-- ORDS ENABLE OBJECT                       0
-- 
-- ERRORS                                   0
-- WARNINGS                                 0
